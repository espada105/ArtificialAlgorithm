# 분할 정복 알고리즘
# 동작 원리
# 분할 정복 알고리즘은 크게 3단계로 이뤄짐

# 1. 분할(Divide)
# 문제를 더 작은 부분 문제로 나눔
# 예를 들어, 배열을 반으로 나누거나 큰 문제를 여러조각으로 쪼갬

# 2. 정복(Conquer)
# 분할 된 부분 문제를 재귀적으로 해결
# 해결된 각 부분은 더 이상 쪼갤 수 없는 기본적인 형태가 된(예/ 배열 길이1)

# 3. 병합(Combine)
# 해결된 부분 문제를 다시 합쳐서 원래 문제의 해답을 구함
# 정렬된 배열을 병합하거나, 결과를 조합하는 단계

# 분할 정복 알고리즘
# 사용예시
# 정렬 알고리즘 : 병합 정렬, 퀵 정렬
# 이진 탐색: 정렬된 데이터에서 특정 값을 빠르게 찾음
# 최소/최대 값 찾기: 배열을 반으로 나눠 비교
# 행렬 곱셈: Strassen 알고리즘 등 효율적인 행렬 연산
# 기하학 문제: 최근접 점 문제, 선분 교차 여부 확인 등

# 고급 정렬(성능이 좋음)
# • 퀵 정렬 (Quick Sort)
# - 분할 정복 알고리즘
# - 피벗을 기준으로 작은 값과 큰 값을 나눔
# - 왼쪽은 피벗보다 작게, 오른쪽은 피벗보다 크게 정렬함
# - 재귀적으로 나눠서 정렬 완료

# 동작 과정
# 1. 배열에서 피벗 선택
# 2. 피벗보다 작은 값을 왼쪽으로 큰 값을 오른쪽으로 분할
# 3. 분할된 부분 배열을 다시 퀵 정렬로 정렬
# 4. 모든 부분 배열이 정렬되면 완료

# 예시: [5, 3, 8, 4, 2]
# 피벗: 4
# 분할:[3,4] [4] [5,8]
# 정렬후: [2,3,4,5,8]

# 특징
# • 시간복잡도
# • 평균: O(n log n)
# • 최악: O(n²) (피벗 선택이 최악일 경우)
# • 공간복잡도: 평균: O(log n) (재귀 호출 스택)
# • 장점: 데이터가 많아도 빠름.
# • 단점: 불안정 정렬(같은 값의 순서가 유지되지 않음)
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)

arr = [5,3,8,4,2]
print(quick_sort(arr))

# • 퀵 정렬에서 불안정성이 발생하는 이유
# • 퀵 정렬은 피벗을 기준으로 작은 값과 큰 값을 분할하면서 정렬을 수행
# 함
# • 이 과정에서 같은 값(피벗과 같은 값 포함)이 왼쪽이나 오른쪽으로 이
# 동하면서, 원래 순서가 유지되지 않음
# • 예시
# • 초기 배열: [5a, 3, 5b, 2]
# • 피벗 선택: 3
# • 분할 결과: [2] | 3 | [5a, 5b]
# • 분할 후 합치기
# • [2, 3, 5b, 5a] (원래 [5a]가 먼저였지만, 순서가 바뀜)

#  왜 불안정성이 문제가 될까?
# • 데이터의 의미가 달라지는 경우 문제가 될 수 있음
# • 예를 들어, 학생 성적 리스트를 정렬할 때, 점수는 같지만 이름 순서가
# 중요할 수 있음
# • 안정 정렬이라면, 점수가 같은 경우에도 이름 순서가 유지됨
# • 불안정 정렬이라면, 이름 순서가 섞여버릴 수 있음

# • 퀵 정렬을 안정 정렬로 바꾸는 방법
# • 같은 값을 왼쪽과 오른쪽으로 나눌 때, 원래 순서를 보존하도록 구현을
# 수정해야 함.
# • 예를 들어, 리스트의 인덱스 정보를 함께 저장하거나, 추가적인 데이터
# 구조를 활용
# • 퀵 정렬은 불안정 정렬이기 때문에, 같은 값을 가진 요소들의 원
# 래 순서가 유지되지 않을 수 있음
# • 데이터의 순서가 중요한 경우에는 다른 안정 정렬(예: 병합 정렬,
# 삽입 정렬)을 사용하는 것이 더 적합함






# • 병합 정렬 (Merge Sort)
# 분할 정복 알고리즘
# • 배열을 절반으로 나누고, 나눠진 부분을 각각 정렬한 뒤 병합함
# • 재귀적으로 진행해서 최종적으로 정렬된 배열을 만듦

# • 동작 과정
# • 분할
# • 배열을 반으로 계속 나눔
# • 더 이상 나눌 수 없을 때까지 나눔. (길이 1이 될 때까지)
# • 정렬 및 병합
# • 나눠진 배열을 작은 값부터 병합하여 정렬된 배열 생성.
# • 최종 배열 완성
# • 병합된 부분들을 합쳐서 전체 배열이 정렬됨.
# • 예시: [5, 3, 8, 1]
# • 분할: [5, 3] | [8, 1] → [5] [3] | [8] [1]
# • 병합: [3, 5] | [1, 8]
# • 정렬된 배열: [1, 3, 5, 8]



def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result

arr1 = [5,3,8,1]
print(merge_sort(arr1))

# 병합 정렬
# • 특징
# • 시간복잡도
# • 최선, 평균, 최악: O(n log n)
# • 공간복잡도
# • 추가 메모리 사용: O(n)
# • 장점
# • 안정 정렬임 (같은 값의 순서 유지)
# • 데이터 크기와 관계없이 일관된 성능
# • 단점
# • 메모리 사용량이 많음


# 정렬 알고리즘 비교
# • 정렬 알고리즘은 데이터 정리에 필수적임
# • 작은 데이터는 기본 정렬, 큰 데이터는 고급 정렬 사용 권장
# • 성능이 중요한 경우 시간 복잡도를 고려해야 함
